# Redux 介绍

> A Predictable State Container for JS Apps

1. **Redux 出现的的背景**

    1. 前面在组件通信时讨论了组件嵌套中常规的组件通信方式带来的问题，Redux 帮我们做状态管理有更好的开发体验。 
  
    2. 单向数据流(one-way data flow)，将让状态更新变得可预测。
    
    ![](https://github.com/kongyufei5039/react-docs/blob/main/image/one-way-data-flow.png)

2. **Redux 的工作流程**

    ![](https://github.com/kongyufei5039/react-docs/blob/main/image/redux-data-flow-diagram.gif)

3. **Redux 源码流程**

    1. createStore
        
    ```typescript
      /**
      * @param reducer A function that returns the next state tree, given the current state tree and the action to handle.
      * @param preloadedState The initial state.
      * @param enhancer The store enhancer. The only store enhancer that ships with Redux is `applyMiddleware()`.
      * @returns A Redux store that lets you read the state, dispatch actions and subscribe to changes.
      */
      export default function createStore<
      S,
      A extends Action,
      Ext = {},
      StateExt = never
      >(
      reducer: Reducer<S, A>,
      preloadedState?: PreloadedState<S> | StoreEnhancer<Ext, StateExt>,
      enhancer?: StoreEnhancer<Ext, StateExt>
      ): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext {
          // 如果第2个参数为 function，第3个参数未传，调换这两个参数的值
          if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
              enhancer = preloadedState as StoreEnhancer<Ext, StateExt>
              preloadedState = undefined
          }

          // 第3个参数为 function 时直接调用，并将 createStore 作为参数传入，这里的 enhancer 实际上是 `applyMiddleware()`。
          if (typeof enhancer !== 'undefined') {
              if (typeof enhancer !== 'function') {
                  throw new Error('Expected the enhancer to be a function.')
              }

              return enhancer(createStore)(
                  reducer,
                  preloadedState as PreloadedState<S>
              ) as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext
          }

          // reducer 必须是一个函数。
          if (typeof reducer !== 'function') {
             throw new Error('Expected the reducer to be a function.')
          }

          // 声明一些变量，保存一些值。
          let currentReducer = reducer
          let currentState = preloadedState as S
          let currentListeners: (() => void)[] | null = []
          let nextListeners = currentListeners
          let isDispatching = false

          /**
          * This makes a shallow copy of currentListeners so we can use
          * nextListeners as a temporary list while dispatching.
          *
          * This prevents any bugs around consumers calling
          * subscribe/unsubscribe in the middle of a dispatch.
          */
          function ensureCanMutateNextListeners() {
              if (nextListeners === currentListeners) {
                  nextListeners = currentListeners.slice()
              }
          }

          function getState(): S {}
  
          function subscribe(listener: () => void) {}
  
          function dispatch(action: A) {}
  
          function replaceReducer<NewState, NewActions extends A>(
              nextReducer: Reducer<NewState, NewActions>
          ): Store<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext {}
  
          function observable() {}
      }
    ```
        
    2. getState

    ```typescript
      /**
       * Reads the state tree managed by the store.
       *
       * @returns The current state tree of your application.
       */
      function getState(): S {
        if (isDispatching) {
          throw new Error(
            'You may not call store.getState() while the reducer is executing. ' +
              'The reducer has already received the state as an argument. ' +
              'Pass it down from the top reducer instead of reading it from the store.'
          )
        }

        return currentState as S
      }
    ```
    
    3. subscribe
    
    ```typescript
      /**
       * 添加一个更改监听器。每当 dispatch action 时，都会调用它，并且 state tree 的某些部分可能已更改。
       * 然后可以调用 `getState()` 来读取回调中的当前 state tree。
       *
       * 在更改监听器中调用 `dispatch()` 要注意：
       * 
       * 1. 订阅是在每次`dispatch（）`调用之前快照的。 如果您在监听器被调用时订阅或取消订阅，这不会对当前正在进行的`dispatch（）`产生任何影响
       * 但是，下一个`dispatch（）`调用，无论是否嵌套，都将使用 订阅列表的最新快照。
       * 2. 监听器不应期望看到所有状态更改，因为在调用侦听器之前，该状态可能在嵌套的“ dispatch（）”期间已多次更新。
       * 但是，可以保证在`dispatch（）`启动之前注册的所有订户将在退出时以最新状态被调用。
       *
       * @param listener A callback to be invoked on every dispatch.
       * @returns A function to remove this change listener.
       */
      function subscribe(listener: () => void) {
        // 校验 listener 的类型
        if (typeof listener !== 'function') {
          throw new Error('Expected the listener to be a function.')
        }
        
        // 禁止在 dispatching(reducer中) 调用 subscribe。
        if (isDispatching) {
          throw new Error(
            'You may not call store.subscribe() while the reducer is executing. ' +
              'If you would like to be notified after the store has been updated, subscribe from a ' +
              'component and invoke store.getState() in the callback to access the latest state. ' +
              'See https://redux.js.org/api/store#subscribelistener for more details.'
          )
        }
        
        // 上锁，防止多次调用 unsubscribe
        let isSubscribed = true
        
        // 确保 currentListener 与 nextListener 不指向同一个引用
        ensureCanMutateNextListeners()
        
        // 注册监听函数
        nextListeners.push(listener)
        
        // 返回取消订阅 listener 的方法
        return function unsubscribe() {
          if (!isSubscribed) {
            return
          }

          if (isDispatching) {
            throw new Error(
              'You may not unsubscribe from a store listener while the reducer is executing. ' +
                'See https://redux.js.org/api/store#subscribelistener for more details.'
            )
          }

          // 解锁
          isSubscribed = false

          再次确保 currentListener 与 nextListener 不指向同一个引用
          ensureCanMutateNextListeners()
          
          // nextListeners 删除 listener
          const index = nextListeners.indexOf(listener)
          nextListeners.splice(index, 1)
          currentListeners = null
        }
      }
    ```
